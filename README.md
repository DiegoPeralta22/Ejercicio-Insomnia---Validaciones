Este proyecto consiste en una API REST construida con Node.js y Express, organizada bajo el patrón Modelo–Vista–Controlador (MVC). La idea principal es tener bien separadas las responsabilidades de cada parte de la aplicación, de forma que el código sea más claro y fácil de mantener.

En el modelo se encuentra la definición de lo que sería nuestra “base de datos en memoria”. En lugar de conectar a una base real, definimos un arreglo con algunos usuarios iniciales, cada uno con su id, nombre, email, edad y estado activo. Para el id utilizamos la función randomUUID de Node.js, que nos garantiza que cada usuario tenga un identificador único. El modelo incluye funciones para manipular este arreglo: obtener todos los usuarios, buscar uno por id, agregar un nuevo usuario y actualizar uno existente. Aquí no nos preocupamos por validar nada, el modelo simplemente recibe datos y los acomoda según la estructura definida.

En el controlador es donde realmente le damos lógica a la aplicación. Cada función corresponde a una operación que el cliente puede solicitar. Por ejemplo, tenemos findAll que pide al modelo la lista de usuarios y la devuelve como respuesta HTTP en formato JSON, findById que busca un usuario específico y responde con él o un 404 si no existe, addUser que valida los datos antes de crear un nuevo registro, y updateUser que revisa los datos enviados y actualiza solo lo que corresponda. Aquí es también donde implementamos la validación, revisando que el nombre no tenga números, que la edad sea un número válido entre 1 y 100 y que el email tenga el formato correcto con arroba y punto. Si algo no cumple, el controlador corta la ejecución y responde con un error claro en lugar de dejar pasar datos incorrectos al modelo.

Las rutas actúan como los caminos que llevan a cada controlador. Definimos endpoints como GET /api/users para obtener todos los usuarios, GET /api/users/:id para buscar por id, POST /api/users para crear y PUT /api/users/:id para actualizar. Cada ruta está conectada con la función del controlador que le corresponde, de modo que Express sabe qué hacer según la URL y el método HTTP que reciba.

Finalmente, en app.js levantamos el servidor con Express, configuramos el uso de JSON en las peticiones y montamos nuestras rutas bajo la ruta base /api/users. El servidor queda escuchando en el puerto 3000 (o el que se defina en las variables de entorno) y a partir de ahí ya podemos probar todo con herramientas como Insomnia o Postman.

En resumen, este proyecto me permitió entender cómo aplicar el patrón MVC en una API REST: el modelo administra los datos, el controlador gestiona la lógica de negocio y las validaciones, y las rutas definen los accesos.
